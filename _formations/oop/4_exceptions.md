---
layout: page
title: TP4
permalink: /oop/exceptions/
importance: 8
description: >
  Gestion des exceptions et cr√©ation de tests
category: BUT 2 - Programmation Orient√©e Objet
visible: true
type: formation
mermaid:
  enabled: true
  zoomable: true
---

# Bonnes pratiques de d√©veloppement

L'objectif de ce TP est de vous familiariser avec les bonnes pratiques de d√©veloppement en Python. Vous allez apprendre √† g√©rer les exceptions et √† cr√©er des tests unitaires pour valider le bon fonctionnement de votre code. Il est important de tester votre code pour vous assurer qu'il fonctionne correctement et pour anticiper les erreurs.

:warning: Veillez √† mettre en pratique les bonnes pratiques de d√©veloppement suivantes :

- **Gestion des exceptions** : utilisez des exceptions pour g√©rer les erreurs et les cas limites.
- **Tests unitaires** : cr√©ez des tests unitaires pour valider le bon fonctionnement de votre code.
- **Documentation** : documentez votre code pour expliquer son fonctionnement et son utilisation.
- **Type hints** : utilisez les annotations de type pour sp√©cifier les types des param√®tres et des valeurs de retour.

Tous ces √©l√©ments seront pris en compte dans le TP not√©. :wink:

---

## Exercice 1 : Pok√©Tech Corp üéÆ

**Contexte :**
Tu viens d‚Äô√™tre embauch√© par la Pok√©Tech Corp pour d√©velopper un simulateur de combat Pok√©mon !

Ta mission ? Impl√©menter un syst√®me de gestion de Pok√©mon avec des classes bien con√ßues, tester leur bon fonctionnement avec `unittest` et g√©rer les erreurs avec des exceptions personnalis√©es.

```mermaid
classDiagram
    class Pokemon {
        + nom : str
        + type : str
        + hp : int
        + attack : int
        + __init__(nom: str, type: str, hp: int, attack: int)
        + __str__() str
        + fight(other: Pokemon) void
    }
    
    class PokemonTrainer {
        + team : list~Pokemon~
        + __init__(team: list~Pokemon~)
        + choose_pokemon() Pokemon
        + fight(opponent: Pokemon) void
    }
    PokemonTrainer o-- Pokemon
    
    class IncorrectPokemonException
    Pokemon --> IncorrectPokemonException
    PokemonTrainer --> IncorrectPokemonException
```

**Question 1** : Impl√©menter une classe `Pokemon` avec les attributs suivants :  
- `nom` : le nom du Pok√©mon.  
- `type` : le type √©l√©mentaire du Pok√©mon (ex: Feu, Eau, Plante).  
- `hp` : *hit points* qui correspondent aux points de vie (PV) du Pok√©mon qui doivent √™tre ‚â• 0.  
- `attack` : la puissance d‚Äôattaque du Pok√©mon (doit √™tre ‚â• 0).  

üí° **Exception √† coder :** Cr√©er une exception `IncorrectPokemonException` qui sera lev√©e si les PV ou l‚Äôattaque sont n√©gatifs.

Ajouter les m√©thodes suivantes :  
- `__str__()` : afficher les infos du Pok√©mon.  
- `fight(other: Pokemon)` : r√©duire les PV de l‚Äôautre Pok√©mon en fonction de l‚Äôattaque.  
- S‚Äôassurer que `hp` et `attack` sont positifs ; sinon lever une exception `IncorrectPokemonException`.

**Question 2** : Tests avec `unittest` :  
- V√©rifier que la cr√©ation d‚Äôun Pok√©mon avec une attaque ou des PV n√©gatifs l√®ve bien une exception.  
- Tester la m√©thode `fight()` en s‚Äôassurant que les PV sont bien r√©duits apr√®s un coup.  

**Question 3** : Ajouter une classe `PokemonTrainer` (dresseur) qui poss√®de une √©quipe de Pok√©mon.
- Impl√©menter une m√©thode pour choisir un Pok√©mon et le faire combattre.  
- G√©rer le cas o√π un Pok√©mon est KO avec une exception `IncorrectPokemonException`.

üß™ **√Ä toi de jouer !** Teste ton code, corrige les erreurs et assure-toi que ton simulateur est digne d‚Äôun vrai dresseur Pok√©mon !

---

## Exercice 2 : r√©servation de places d'avion :airplane:

Vous devez √©crire un programme qui permet de r√©server des places dans un avion. Le programme doit permettre de r√©server une place, de lister les places disponibles et de lister les places r√©serv√©es.

```mermaid
classDiagram
    class PlaneSeats {
        + capacity : int
        + available_seats : list
        + reserved_seats : list
        + __init__(capacity: int)
        + reserve_seats(seats: list) void
        + get_available_seats() list
        + get_reserved_seats() list
        + get_total_seats() int
    }

    class SeatCountError
    class SeatUnavailableError
    class SeatDoesNotExistError
    PlaneSeats --> SeatCountError
    PlaneSeats --> SeatUnavailableError
    PlaneSeats --> SeatDoesNotExistError
```

**Question 1** : D√©finissez la classe `PlaneSeats` avec les attributs suivants :

- `capacity` : le nombre de places totales disponibles dans l‚Äôavion.
- `available_seats` : la liste des places disponibles (initialis√©e avec les num√©ros de places de 1 √† `capacity`).
- `reserved_seats` : la liste des places d√©j√† r√©serv√©es (vide √† l‚Äôinitialisation).

**Question 2** : Cr√©ez une m√©thode `reserve_seats` prenant une liste de num√©ros de si√®ges en argument et devant avoir le comportement suivant :

- **V√©rification du nombre de places disponibles** :
  - Si le nombre de places disponibles est inf√©rieur au nombre de places demand√©es, lever une erreur du type `SeatCountError`.
- **V√©rification de la disponibilit√© du si√®ge** :
  - Si le si√®ge est d√©j√† r√©serv√©, lever une erreur du type `SeatUnavailableError`.
  - Sinon, ajouter le si√®ge √† la liste des places r√©serv√©es.

**Question 3** : Cr√©ez une exception personnalis√©e `SeatDoesNotExistError` qui sera lev√©e si un si√®ge demand√© n‚Äôexiste pas dans l‚Äôavion.

**Question 4** : Modifiez la m√©thode `reserve_seats` de mani√®re √† ne r√©server les places demand√©es que si l‚Äôensemble des places demand√©es r√©pondent aux conditions suivantes :

- Le nombre de places demand√©es n‚Äôexc√®de pas le nombre de places disponibles.
- Toutes les places existent dans l‚Äôavion.
- Aucune des places demand√©es n‚Äôest d√©j√† r√©serv√©e.
- Dans le cas contraire, ne pas r√©server de place.

**Question 5** : Cr√©ez une m√©thode `get_available_seats` permettant de lister les places disponibles dans l‚Äôavion.

**Question 6** : Cr√©ez une m√©thode `get_reserved_seats` permettant de lister les places d√©j√† r√©serv√©es dans l‚Äôavion.

**Question 7** : Cr√©ez une m√©thode `get_total_seats` permettant de conna√Ætre le nombre total de places dans l‚Äôavion.

**Question 8** : Cr√©ez un fichier principal `main.py` permettant d‚Äôinteragir avec la classe `PlaneSeats` et de tester les diff√©rentes fonctionnalit√©s.

- Cr√©ez une instance de la classe `PlaneSeats` contenant 20 places.
- R√©servez 5 places : places 2, 5, 8, 10 et 15.
- Affichez les places disponibles.
- R√©servez la place 5, cela doit lever une erreur `SeatUnavailableError`.
- R√©servez 10 places : places 1, 3, 6, 7, 9, 11, 12, 16, 18 et 20.
- R√©servez la place 21, cela doit lever une erreur `SeatDoesNotExistError`.
- Affichez les places r√©serv√©es.
- Affichez le nombre total de places.

<!--

## Exercice 3 : polygones

Pour cet exercice, nous allons cr√©er des polygones. Pour cela, nous avons besoin d'un point, vous pouvez r√©utiliser la classe `Point` du TP2.  

#### Contraintes √† impl√©menter :  
- Un **polygone** est d√©fini par une suite finie et ordonn√©e de points qu‚Äôon nomme **sommets** (pour simplifier, on supposera que les polygones sont convexes, sauf √† la derni√®re question optionnelle).  
- On peut **calculer l‚Äôaire et le p√©rim√®tre** d‚Äôun polygone.  
- Un polygone avec **2 sommets** est un **segment** dont le p√©rim√®tre est la longueur du segment, et l‚Äôaire est nulle.  
- Deux sommets successifs (ainsi que les premier et dernier sommets) du polygone forment un **segment**, qu‚Äôon nomme un **c√¥t√© du polygone**.  
- Un **triangle** est un polygone avec **3 sommets**.  
- L‚Äôaire d‚Äôun **triangle** peut √™tre obtenue avec la formule de H√©ron : $$ S = \sqrt{p(p - a)(p - b)(p - c)} $$ avec $$ p = \frac{a+b+c}{2} $$ et $$ a, b, c $$ les longueurs de ses c√¥t√©s.  
- Un **quadrilat√®re** est un polygone √† **4 sommets** (on le supposera convexe ‚Äì ses c√¥t√©s ne se coupent pas).  
- L‚Äôaire d‚Äôun **quadrilat√®re** peut √™tre obtenue en le divisant en deux triangles, et en sommant les aires de ces triangles.  
- Un **rectangle** est un **quadrilat√®re** dont les **c√¥t√©s oppos√©s sont de m√™me longueur** et ayant un **angle droit** (condition suffisante car les quadrilat√®res sont suppos√©s convexes).  
- L‚Äôaire d‚Äôun **rectangle** est le **produit des longueurs de deux c√¥t√©s adjacents**.  

#### Travail √† r√©aliser  

1. **Identifiez les classes, les attributs, les m√©thodes, les associations et les g√©n√©ralisations** dans l‚Äô√©nonc√© ci-dessus. En d‚Äôautres termes, √©crivez le **diagramme de classes**.  
2. **Impl√©mentez votre diagramme de classe.** Vous veillerez √† impl√©menter la m√©thode `__str__` (soit directement dans la classe, soit par h√©ritage).  
3. **√âcrivez un module `__main__.py`** avec des tests de votre code. 
4. On souhaite ajouter la cr√©ation d‚Äôun **polygone r√©gulier** tel que ses **sommets sont r√©guli√®rement espac√©s** sur un cercle dont le **centre et le rayon** sont donn√©s. L‚Äôangle par rapport √† l‚Äôaxe des abscisses du **premier sommet** est √©galement fourni. **Modifiez votre diagramme de classe et votre code.**  
5. (**Surcharge d‚Äôop√©rateur**) **Surchargez l‚Äôaddition** pour la classe `Segment` (m√©thode `__add__(self, x)`).  
   - Ajouter un **Point** donne un **Triangle**.  
   - Ajouter un **Segment** donne un **Quadrilat√®re** (on s‚Äôassurera que ses c√¥t√©s ne se croisent pas).  
   - Ajouter un **Polygone** donnera un **nouveau polygone**.  
   - Vous pourrez utiliser la fonction `isinstance(x, Point)` pour tester si l‚Äôobjet `x` appartient √† la classe `Point`.  
6. Lors de la cr√©ation d‚Äôun **polygone**, v√©rifiez que celui-ci est **bien convexe**, et **levez une exception** dans le cas contraire.  
   - Cr√©ez une nouvelle **exception** (d√©rivant de la classe de base `Exception`).  
   - Ajoutez cette classe au **diagramme de classe**.  

-->